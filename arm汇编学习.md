learning... 参考https://www.jianshu.com/c/c1915233fab8
## 1. 基础数据类型
    byte 0~7 bit
    half word 0~15 bit
    word 0~32 bit

---

    一些数据类型的命令
    LDR    : ← ？ Word 4B
    LDR H  : 无符号半字 half word 2B
    LDR SH : 有符号半字 sigh half word 2B
    LDR B  : 无符号字节 byte 1B
    LDR SB : 有符号字节 sigh byte 1B
    
    STR    : → 同上 
    有无符号，大小均一样
    
    
## 2. 字节序
    大端序：BE , big endian 
        最 高 字节存在 最低 的地址
    小端序：LE , little endian 
        最 低 字节存在 最低 的地址
    例：
    一个int的16进制的整数：0x12345678 在内存中存储


![http://note.youdao.com/noteshare?id=53249649cfcfaead0a042cf4454f68d4](https://github.com/CongCode/studyDaily/blob/master/image/big-little.png)
#####     个人理解:
    数据（123456）是左边是大的习惯，
    地址是以左边由小开始习惯
    大端序就是直接把数据直接套进去
    小端序即正常的，小的对小的，打的对大的，这个理应为准确逻辑
    =======但是，从上图中，如果从反的思维来看，从 地址 中读出 数据 ，
    ~~~~~请看地址中的数据~~~~~
    大端序从左到右很容易得出是0x 12 34 56 78 
    而小端序，如果从左到右看的话是0x 78 56 34 12 ，这是错误的，需要反过来读数据才可以的到正确的，
    要先12 再读34，拼接12和34，不能直接2143！！！！不要混乱。
    在逆向实际中看到很多都是小端序，对于没有理解透的，经常会搞混乱，搞成2143，3412。
    
## 3. 寄存器
    在ARMv6-M与ARMv7-M的处理器中有30个32bit位宽度的通用寄存器，前16个寄存器是用户层可访问控制。
    R0~R6  ---通用寄存器
    R7     ---一般放系统调用号
    R8~R10 ---通用寄存器
    R11   ----FP----栈帧指针
    R12   ----IP----内部程序调用
    R13   ----SP----内部程序调用 ///////////
    R14   ----LR----链接寄存器(一般存放函数返回地址) ///////////
    R15   ----PC---- PC指针，理论上，PC寄存器应指向即将执行的下一条指令的地址，然而在实际应用中却发现PC寄存器总不是如此，可以通过调试验证。详情：https://www.cnblogs.com/ichunqiu/p/9056630.html
    CPSR   当前程序状态寄存器 ///////////
#####     详解:
    其中 r0~r3 主要用于子程序间 传递参数，超出的参数通过 堆栈 来传递，
    同时R0也用于存放 函数的 返回值。
    r4~r11 主要用于保存局部变量，但在 Thumb 程序中，通常只能使用 r4~r7 来保存局部变量。
    CPSR:当前程序状态寄存器(current program status register)(当前程序状态寄存器)，在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户级编程时用于存储条件码。
    N (Negative)	指令结果为负值时置1
    Z (Zero)	    指令结果为零值时置1
    C (Carry)	    对于加法有进位则置1，对于减法有借位则置0
    V (Overflow)	指令结果不能用32位的二进制补码存储，即发生了溢出时置1
    ...

## 3. 寻址方式
    ...
    
## 4. ARM模式与thumb模式  
    ...
## 5. 指令详解
    ...
## 4. 指令详解
    ...
    