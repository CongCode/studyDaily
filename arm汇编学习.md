learning... 
---
我的基础已经学过8086汇编，目的：使用ida逆向分析arm汇编的so库。参考：https://www.jianshu.com/c/c1915233fab8 和各种文章 
https://www.cnblogs.com/xiaojiang1025/p/5951461.html  
https://www.cnblogs.com/lifexy/p/7363208.html  
https://www.cnblogs.com/armlinux/archive/2011/09/20/2396810.html
## 1. 基础数据类型
    byte 0~7 bit
    half word 0~15 bit
    word 0~32 bit

---

    一些数据类型的命令
    LDR    : ← ？ Word 4B
    LDR H  : 无符号半字 half word 2B
    LDR SH : 有符号半字 sigh half word 2B
    LDR B  : 无符号字节 byte 1B
    LDR SB : 有符号字节 sigh byte 1B
    
    STR    : → 同上 
    有无符号，大小均一样
    
    
## 2. 字节序
    大端序：BE , big endian 
        最 高 字节存在 最低 的地址
    小端序：LE , little endian 
        最 低 字节存在 最低 的地址
    例：
    一个int的16进制的整数：0x12345678 在内存中存储

![http://note.youdao.com/noteshare?id=53249649cfcfaead0a042cf4454f68d4](https://github.com/CongCode/studyDaily/blob/master/image/big-little.png)
#####     个人理解:
    数据（123456）是左边是大的习惯，
    地址是以左边由小开始习惯
    大端序就是直接把数据直接套进去
    小端序即正常的，小的对小的，打的对大的，这个理应为准确逻辑
    =======但是，从上图中，如果从反的思维来看，从 地址 中读出 数据 ，
    ~~~~~请看地址中的数据~~~~~
    大端序从左到右很容易得出是0x 12 34 56 78 
    而小端序，如果从左到右看的话是0x 78 56 34 12 ，这是错误的，需要反过来读数据才可以的到正确的，
    要先12 再读34，拼接12和34，不能直接2143！！！！不要混乱。
    在逆向实际中看到很多都是小端序，对于没有理解透的，经常会搞混乱，搞成2143，3412。
    
## 3. 寄存器
    在ARMv6-M与ARMv7-M的处理器中有30个32bit位宽度的通用寄存器，前16个寄存器是用户层可访问控制。
    R0~R6  ---通用寄存器
    R7     ---一般放系统调用号
    R8~R10 ---通用寄存器
    R11   ----FP----栈帧指针
    R12   ----IP----内部程序调用
    R13   ----SP----内部程序调用 堆栈指针///////////
    R14   ----LR----链接寄存器(一般存放函数返回地址) ///////////
    R15   ----PC---- PC指针，理论上，PC寄存器应指向即将执行的下一条指令的地址，然而在实际应用中却发现PC寄存器总不是如此，可以通过调试验证。  
    详情：https://www.cnblogs.com/ichunqiu/p/9056630.html
    CPSR   当前程序状态寄存器 ///////////
#####     详解:
    其中 r0~r3 主要用于子程序间 传递参数，超出的参数通过 堆栈 来传递，
    同时R0也用于存放 函数的 返回值。
    r4~r11 主要用于保存局部变量，但在 Thumb 程序中，通常只能使用 r4~r7 来保存局部变量。
    CPSR:当前程序状态寄存器(current program status register)(当前程序状态寄存器)，在任何处理器模式下被访问。 
    它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。CPSR在用户级编程时用于存储条件码。
    N (Negative)	指令结果为负值时置1
    Z (Zero)	    指令结果为零值时置1
    C (Carry)	    对于加法有进位则置1，对于减法有借位则置0
    V (Overflow)	指令结果不能用32位的二进制补码存储，即发生了溢出时置1
    ...

## 3. 寻址方式
#####     ARM有9种寻址方式:
    立即寻址，寄存器寻址，寄存器间接寻址，寄存器移位寻址，基址变址寻址，相对寻址，多寄存器寻址，堆栈寻址（块拷贝寻址）
---
####     1.立即寻址: 
    即后面直接是操作数。
    MOV    R0，#0xFF000          ；将立即数0xFF000装入R0寄存器
    另类： SUBS   R0,   R0,#1              ；R0减1，  结果放入R0中，并且影响标志位 ？？subs 多了个s？
    ARM规定：这个立即数必须符合8位图格式，负责必须使用“文字池”方式， 
    通过存储器访问指令加载，所谓的8位图格式就是指，这个数据能通过一个8bit的数循环右移偶数位得到。？？
####     2.寄存器寻址: 
    操作数的值在寄存器中，使用寄存器值。
    MOV   R1，R2                ；将R2的值存入R1
    另类： MOV   R0,R1,R2              ；将R1的值|减|去R2的值，结果存到R0  ？？为什么是减，有点古怪，是sub才减，
    怀疑看的文章是不是写错了，
    所有书本才是王道，书本又是不说人话。
####     3.寄存器间接寻址: 
    [R0],R0中存的地址相关的量，说白了给出地址，拿地址上的值赋值。
    
    LDR R0，[R1]                ；将R1指向的数据加载到R0中
    这里是LDR,mov只能在寄存器之间移动数据，或者把立即数移动到寄存器中,
    LDR能从地址中获取
    
    另类： STR R0, [R1]!        ；将R0存储的数据加载到R1指向的地址中，加载完毕R1中为操作后的地址。？？人话？
    这个感叹号有点迷糊，作者解释，将操作后的结果地址给R1，意思是这个命令后地址会变？然后把地址给R1，
    结果地址是什么鬼？。。。。。。。。。。。。
    
    另类：ADD R0，R1，[R2]    ；作者没解释？好想看书。我猜是[R2]加R1，然后赋值给R0
    
####     4.寄存器移位寻址: 
    ARM处理器特有的寻址方式。
    先寄存器的值进行移位，在赋值。
    MOV R0 ，  R2，  LSL  #1   ；R2的值左移1位，结果赋给R0。LSL左移
 
LSL：逻辑左移（Logical Shift Left），寄存器中字的低端空出的位补0。  
LSR：逻辑右移（Logical Shift Right），寄存器中字的高端空出的位补0。  
ASL：算术左移（Arithmetic Shift Left），和逻辑左移LSL相同。？？  
ASR：算术右移（Arithmetic Shift Right），移位过程中符号位不变，即如果源操作数是正数，则字的高端空出的位补0，否则补１。？？  
ROR：循环右移（Rotate Right），由字的低端移出的位填入字的高端空出的位。？？  
RRX：带扩展的循环右移（Rotate Right eXtended），操作数右移一位，高端空出的位用进位标志C的值来填充，低端移出的位填入进位标志位。？？

####     5.基址变址寻址: 
    可以看作寄存器间接寻址的增强版。就是地址计算后再赋值
    LDR R0，[R1，#4]    ;取R1的内容当作主存的地址，在此基础上+4byte，从该地址处取操作数。
    LDR R0，[R1，#4]！  ;同上，操作完毕后，！表示指令执行完毕把最后的数据地址写到R1，即R1原来的地址+4.
    感叹号就是让R1的地址加4再赋值给R1,那前面的结果地址会不会变？
    
    LDR R0，[R1，R2]    ;R1和R2的内容相加当做地址，取得的操作数存入寄存器R0中
    STR R0， [R1，#-4] ；将R1中的数值减4作为地址，把R0中的数据存放到这个地址中。
    LDR R0，[R1]，   #4   ；把R1指向的数据放到R0中，     操作完成后[R1]自增4byte
    
####     6.相对寻址: 
    通过使用语句的中的标号进行寻址，通常配合跳转指令使用
    BL   FCN  ；相对寻址，跳转FCN处执行。
        ...
    FCN:
        ...
    跳转指令之后再讲 B BL BX .....
####     7.多寄存器寻址: 
    一次可传送几个寄存器的值
    允许一条指令传送16个寄存器的任何子集或
    
    LDMIA   R1!,{R2-R7,R12}；将R1指向的单元中的数据读出到R2---R7、R12中（R1自自动 ??）

    STMIA   R0!，{R2-R7，R12}；将R2---R7、R12中的数据一次读入到R0指向的单元中（R0自动 ??）
    
    LDR R1,=0x10000000          ；传送数据的起始地址0x10000000     
    LDMIB R1!,{R0,R4-R6}      ；从左到右加载,相当于 LDR R0,10000004  LDR R4,10000008 R5=0X1000000C R6=0X10000010
    !, 最后的地址写回到R1中,R1=0X10000010
    
LDM IA、LDM IB、LDM DB、LDM DA、STM IA、LDM FD、LDM FA、LDM ED、LDM EA  

LDM:(load  much)多数据加载,将地址上的值加载到寄存器上，  和LDR 查了个M 表示多个  
STM:(store much)多数据存储,将寄存器的值存到地址上， 和STR 查了个M 表示多个  

主要用途：现场保护、数据复制、参数传送等，共有8种模式（前面4种用于数据块的传输，后面4种是堆栈操作）如下：

（1）IA:（Increase After） 每次传送后地址加4,传后在加

（2）IB:（Increase Before）每次传送前地址加4,传前先加

（3）DA:（Decrease After）每次传送后地址减4

（4）DB：（Decrease Before）每次传送前地址减4

####     8.堆栈寻址: 
 
    堆栈是一种按特定顺序进行存取的存储区，操作顺序分为“先进后出”和“后进先出”，堆栈寻址是隐含的，
    它使用一个专门的寄存器（堆栈指针sp）指向的存储区域（堆栈），指针所指向的存储单元即是堆栈的栈顶。

        存储器堆栈可以分为两种：

          向上生长：递增堆栈

          向下生长：递减堆栈
接上  

（5）FD:  满递减堆栈 (每次传送前地址减4)

（6）FA:  满递增堆栈 (每次传送后地址减4)

（7）ED:  空递减堆栈 (每次传送前地址加4)

（8）EA:  空递增堆栈 (每次传送后地址加4)

    STMFD    SP！，{R1-R7，LR}    ；将R1---R7、LR入栈。满递减堆栈

    LDMFD    SP！，{R1-R7，LR}    ；数据出栈，放入R1---R7、LR寄存器，满递减堆栈

注意：其中在数据块的传输中是STMMDB和LDMIA对应，STMMIA和LDMDB对应

而在堆栈操作是STMFD和LDMFD对应，STMFA和LDMFA对应

## 4. ARM模式与thumb模式  
    ARM模式的指令集宽度是32位而Thumb是16位宽度(但也可以是32位)。
    知道何时以及如何使用Thumb模式对于ARM漏洞利用的开发尤其重要。
    ARM状态和Thumb状态可以直接通过某些指令直接切换，都是在运行程序，只不过指令长度不一样而已。
    
    在标准32位模式下，可以切换到Thumb模式下，这样的话，代码大小会压缩不少，以此提高空间利用率。
    同样的代码，如果用Thumb模式的话，比用普通ARM模式的指令，代码大小最大可以减少大约40%。
    程序可以通过对应的指令，在ARM和Thumb模式之间切换。
    B、BL、BX、BLX ，X是切换状态
## 5. 指令详解
    ...
## 6. C语言的分支条件翻译
    ...
    